/*
 * generated by Xtext
 */
package org.boomslang.generator.geb.feature.core

import org.boomslang.dsl.feature.feature.BAssertion
import org.boomslang.dsl.feature.feature.BCodeStatement
import org.boomslang.dsl.feature.feature.BCommand
import org.boomslang.dsl.feature.feature.BFeature
import org.boomslang.dsl.feature.feature.BFeaturePackage
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BToFrameSwitch
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.naming.IQualifiedNameProvider

import static org.boomslang.generator.geb.feature.ui.GebOutputConfigurationProvider.*

import static extension org.apache.commons.lang.StringEscapeUtils.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import com.wireframesketcher.model.Screen
import org.boomslang.generator.interfaces.IBoomAggregateGenerator
import org.eclipse.emf.ecore.resource.ResourceSet
import org.boomslang.generator.util.CodeSectionStatemachine

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class BFeatureGenerator implements IBoomAggregateGenerator {
	
	@Inject protected extension IQualifiedNameProvider
	
	@Inject extension WidgetTypeRefUtil
	
	@Inject CodeSectionStatemachine codeSectionStatemachine
	
	@Inject BCommandGenerator bCommandGenerator
	
	@Inject BAssertionGenerator bAssertionGenerator
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		if (resource == null) {
			return
		}
		switch (pack : resource.contents.get(0)) {
			BFeaturePackage: {
				for (feature : pack.BFeature) {
					feature.generateBFeature(pack, fsa)
				}
			}
		}
	}

	override getShortDescription() {
		"Default feature generator"
	}

	def void generateBFeature(BFeature it, BFeaturePackage pack, IFileSystemAccess fsa) {
		fsa.generateFile(
			'''«pack.name.replaceAll('''\.''', "/")»/«name»Feature.groovy''',
			OUTPUT_CONFIG_GEB,
			compileBFeature(pack)
		)
	}

	def compileBFeature(BFeature it, BFeaturePackage pack) '''
		package «pack.name»
		
		/** 
		 * Generated by: «shortDescription» 
		 */ 
		class «name»Feature eeextends org.boomslang.features.BoomslangFeature {
		
			«FOR s : it.scenarios»
				«s.compileBScenario»
			«ENDFOR»
		
		}
	'''

	/**
	 * Compiles a test method. If the scenario depends on another scenario, 
	 * compiles the code of the depending scenario also (until we implement
	 * a more elegant method to just reference the depending scenario's code)
	 */
	def compileBScenario(BScenario it) { 
		codeSectionStatemachine.resetSection
	'''
		«IF !comment.nullOrEmpty»
		 «comment.replaceAll('''(\n)\s+\*''',"$1 *")»
		«ENDIF»
		def "«it.name./** TODO ValueConverter */ replaceAll('^"','').replaceAll('"$','').escapeJava»"() {
		
			«it.codeStatements.compileCodeStatements(false, codeSectionStatemachine)»
		
			«IF !it.dataProvider.nullOrEmpty»
				where:
				[«FOR p: it.params.map[name] SEPARATOR ", "»«p»«ENDFOR»] << new «dataProvider»().daten()
			«ENDIF»
		}
		
	'''}

	def CharSequence compileCodeStatements(List<BCodeStatement> it, boolean compilingDependency, CodeSectionStatemachine codeSectionStatemachine) '''
		«IF preScenario != null»
		« /* loop protection already in the validation of the DSL file */
		  preScenario.codeStatements.compileCodeStatements(true, codeSectionStatemachine)»
		«ENDIF»
		«IF compilingDependency»
		/* dependency: code from Scenario «parentScenarioName» */«ENDIF»
		«IF preScenario == null»given:
			to «it.parentScenario.BToScreenSwitch.screen.fullyQualifiedName»Screen«ENDIF»
		«IF preScenario != null && !compilingDependency»
		
		/* the code from Scenario «parentScenarioName» */
		«ENDIF»
		«IF it.nullOrEmpty»println "no commands were given to execute"«ENDIF»
		«FOR codeStatement : it»
		«codeSectionStatemachine.computeSectionHeader(codeStatement)»
		«compileCodeStatementWithFrameWrapper(codeStatement)»
		«ENDFOR»
		
	'''
	
	def compileCodeStatementWithFrameWrapper(BCodeStatement codeStatement) {
		val contextInfo = codeStatement.contextInfoOfNearestContext
		val frameName = contextInfo?.frameName
		val widgetContainer = contextInfo?.widgetContainer
		val widgetContainerName = switch (widgetContainer) {
			Screen : {
				widgetContainer.name				
			}
		}
		if (widgetContainerName.nullOrEmpty) {
			throw new Exception("could not find widget container")
		}
		
		val inFrame = !(codeStatement instanceof BToScreenSwitch) &&
		!(codeStatement instanceof BToFrameSwitch) && 
		frameName != null
		'''
		«IF inFrame»
			withFrame(«frameName», «widgetContainerName») {
		«ENDIF»
			«compile(codeStatement)»
		«IF inFrame»
			}
		«ENDIF»
		'''
	}
	
	// =============================================================================
	// CodeStatement
	// =============================================================================

	/** 
	 * This dispatch method is called when no specific method was found and usually a sign
	 * that the generator should be extended with a dispatch method for a more specific type
	 */
	 def dispatch compile(BCodeStatement it) '''
	 	// WARNING:
	 	// generator does not yet support code statements of type «it.eClass.name»
	 '''

	def dispatch compile(BCommand it) {
		bCommandGenerator.compile(it)
	}
	
	def dispatch compile(BAssertion it) {
		bAssertionGenerator.compile(it)
	}


	// =============================================================================
	// Screen switch
	// =============================================================================
	 
	// switches  context
	def dispatch compile(BToFrameSwitch it) '''
		println("Switching to frame «it.frameID»")
	'''
	
	// TODO FIXME	 
	def dispatch compile(BToScreenSwitch it) '''
		at «it.screen.name»Screen
	'''
	
	// =============================================================================
	// Utility methods
	// =============================================================================
	
	/**
	 * @return the parent BScenario of a given BTestcode
	 */
	def private BScenario preScenario(List<BCodeStatement> it) {
		it.parentScenario?.preScenario
	}
	
	def private String parentScenarioName(List<BCodeStatement> it) {
		it.parentScenario?.name
	}

	def private BScenario parentScenario(List<BCodeStatement> it) {
		it.head?.getContainerOfType(BScenario)
	}

    override doGenerate(ResourceSet input, IFileSystemAccess fsa) {
     // Not needed in this implementation
    }
	

}