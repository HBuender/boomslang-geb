/*
 * generated by Xtext
 */
package org.boomslang.generator.geb.feature.core

import com.google.inject.Inject
import java.util.List
import org.boomslang.dsl.feature.feature.BAssertionComponentActionParameter
import org.boomslang.dsl.feature.feature.BCodeStatement
import org.boomslang.dsl.feature.feature.BCommandComponentActionParameter
import org.boomslang.dsl.feature.feature.BFeature
import org.boomslang.dsl.feature.feature.BFeaturePackage
import org.boomslang.dsl.feature.feature.BScenario
import org.boomslang.dsl.feature.feature.BToScreenSwitch
import org.boomslang.dsl.feature.services.WidgetTypeRefUtil
import org.boomslang.generator.interfaces.IBoomAggregateGenerator
import org.boomslang.generator.util.CodeSectionStatemachine
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.naming.IQualifiedNameProvider

import static org.boomslang.generator.geb.feature.ui.GebOutputConfigurationProvider.*

import static extension org.apache.commons.lang.StringEscapeUtils.*
import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class BFeatureGenerator implements IBoomAggregateGenerator {
	
	@Inject protected extension IQualifiedNameProvider
	
	@Inject CodeSectionStatemachine codeSectionStatemachine
	
	@Inject BCommandGenerator bCommandGenerator
	
	@Inject BAssertionGenerator bAssertionGenerator
	
	@Inject extension WidgetTypeRefUtil 
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		if (resource == null) {
			return
		}
		switch (pack : resource.contents.get(0)) {
			BFeaturePackage: {
				for (feature : pack.BFeature) {
					feature.generateBFeature(pack, fsa)
				}
			}
		}
	}

	override getShortDescription() {
		"Default feature generator"
	}

	def void generateBFeature(BFeature it, BFeaturePackage pack, IFileSystemAccess fsa) {
		fsa.generateFile(
			'''«pack.name.replaceAll('''\.''', "/")»/«name»Feature.groovy''',
			OUTPUT_CONFIG_GEB,
			compileBFeature(pack)
		)
	}

	def compileBFeature(BFeature it, BFeaturePackage pack) '''
		package «pack.name»
		
		/** 
		 * Generated by: «shortDescription» 
		 */ 
		class «name»Feature extends org.boomslang.features.BoomslangFeature {
		
			«FOR s : it.scenarios»
				«s.compileBScenario»
			«ENDFOR»
		
		}
	'''

	/**
	 * Compiles a test method. If the scenario depends on another scenario, 
	 * compiles the code of the depending scenario also (until we implement
	 * a more elegant method to just reference the depending scenario's code)
	 */
	def compileBScenario(BScenario it) { 
		codeSectionStatemachine.resetSection
	'''
		«IF !comment.nullOrEmpty»
		 «comment.replaceAll('''(\n)\s+\*''',"$1 *")»
		«ENDIF»
		def "«it.name./** TODO ValueConverter */ replaceAll('^"','').replaceAll('"$','').escapeJava»"() {
		
			«it.codeStatements.compileCodeStatements(false, codeSectionStatemachine)»
		
			«IF !it.dataProvider.nullOrEmpty»
				where:
				[«FOR p: it.params.map[name] SEPARATOR ", "»«p»«ENDFOR»] << new «dataProvider»().daten()
			«ENDIF»
		}
		
	'''}

	def CharSequence compileCodeStatements(List<BCodeStatement> it, boolean compilingDependency, CodeSectionStatemachine codeSectionStatemachine) '''
		«IF preScenario != null»
		« /* loop protection already in the validation of the DSL file */
		  preScenario.codeStatements.compileCodeStatements(true, codeSectionStatemachine)»
		«ENDIF»
		«IF compilingDependency»
		/* dependency: code from Scenario «parentScenarioName» */«ENDIF»
		«IF preScenario == null»given:
			to «it.parentScenario.BToScreenSwitch.screen.fullyQualifiedName»Screen«ENDIF»
		«IF preScenario != null && !compilingDependency»
		
		/* the code from Scenario «parentScenarioName» */
		«ENDIF»
		«IF it.nullOrEmpty»println "no commands were given to execute"«ENDIF»
		«FOR codeStatement : it»
		«codeSectionStatemachine.computeSectionHeader(codeStatement)»
		«codeStatement.compile»
		«ENDFOR»
		
	'''
	
	// =============================================================================
	// CodeStatement
	// =============================================================================

	/** 
	 * This dispatch method is called when no specific method was found and usually a sign
	 * that the generator should be extended with a dispatch method for a more specific type
	 */
	 def dispatch compile(BCodeStatement it) '''
	 	// WARNING:
	 	// generator does not yet support code statements of type «it.eClass.name»
	 '''

	def dispatch compile(BCommandComponentActionParameter it) {
		bCommandGenerator.compile(it)
	}
	
	def dispatch compile(BAssertionComponentActionParameter it) {
		bAssertionGenerator.compile(it)
	}


	// =============================================================================
	// Screen switch
	// =============================================================================
	 
	
	def dispatch compile(BToScreenSwitch it) '''
		at «it.screen.name»Screen
	'''
	
	// =============================================================================
	// Utility methods
	// =============================================================================
	
	/**
	 * @return the parent BScenario of a given BTestcode
	 */
	def private BScenario preScenario(List<BCodeStatement> it) {
		it.parentScenario?.preScenario
	}
	
	def private String parentScenarioName(List<BCodeStatement> it) {
		it.parentScenario?.name
	}

	def private BScenario parentScenario(List<BCodeStatement> it) {
		it.head?.getContainerOfType(BScenario)
	}

    override doGenerate(ResourceSet input, IFileSystemAccess fsa) {
     // Not needed in this implementation
    }
	

}